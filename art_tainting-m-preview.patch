diff --git a/.gitignore b/.gitignore
index c4cf98b..9ae8928 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1 +1,2 @@
 JIT_ART
++*.swp
diff --git a/Android.mk b/Android.mk
index 3467f1d..c407015 100644
--- a/Android.mk
+++ b/Android.mk
@@ -71,7 +71,7 @@ ifneq ($(art_dont_bother),true)
 ########################################################################
 # cpplint rules to style check art source files
 
-include $(art_path)/build/Android.cpplint.mk
+# include $(art_path)/build/Android.cpplint.mk
 
 ########################################################################
 # product rules
diff --git a/build/Android.common_build.mk b/build/Android.common_build.mk
index 3e427a3..56f5698 100644
--- a/build/Android.common_build.mk
+++ b/build/Android.common_build.mk
@@ -197,7 +197,8 @@ art_cflags := \
   -Wshadow \
   -Wunused \
   -fvisibility=protected \
-  $(art_default_gc_type_cflags)
+  $(art_default_gc_type_cflags) \
+  -DART_TAINTING=1
 
 # Missing declarations: too many at the moment, as we use "extern" quite a bit.
 #  -Wmissing-declarations \
diff --git a/compiler/dex/compiler_ir.h b/compiler/dex/compiler_ir.h
index d28df1d..505e527 100644
--- a/compiler/dex/compiler_ir.h
+++ b/compiler/dex/compiler_ir.h
@@ -203,6 +203,11 @@ struct CompilationUnit {
    * the pass name.
    */
   SafeMap<const std::string, const OptionContent> overridden_pass_options;
+
+#if ART_TAINTING
+  int taint_field_idx = -1;        // the number for the current method's object's "__taint__" field 
+  uint32_t taint_field_offset;
+#endif
 };
 
 }  // namespace art
diff --git a/compiler/dex/mir_graph.cc b/compiler/dex/mir_graph.cc
index 9fa5148..47d0bb5 100644
--- a/compiler/dex/mir_graph.cc
+++ b/compiler/dex/mir_graph.cc
@@ -161,6 +161,11 @@ MIRGraph::MIRGraph(CompilationUnit* cu, ArenaAllocator* arena)
 MIRGraph::~MIRGraph() {
   STLDeleteElements(&block_list_);
   STLDeleteElements(&m_units_);
+#if ART_TAINTING
+  if (art_taintings_ != nullptr) {
+    delete art_taintings_;
+  }
+#endif
 }
 
 /*
@@ -757,6 +762,23 @@ void MIRGraph::InlineMethod(const DexFile::CodeItem* code_item, uint32_t access_
 
   uint64_t merged_df_flags = 0u;
 
+#if ART_TAINTING
+  if (art_taintings_ == nullptr) {
+    art_taintings_ = new std::map<uint32_t, uint32_t>();
+  }
+  const DexFile::ClassDef& class_def = dex_file.GetClassDef(class_def_idx);
+  VLOG(compiler) << "ART_TAINTING - looking for taint field number of field: " << ART_TAINTING_FIELD_NAME;
+  for (size_t i = 0; i < dex_file.NumFieldIds(); i++) {
+    const DexFile::FieldId& field_id = dex_file.GetFieldId(i);
+    std::string field_name(dex_file.GetFieldName(field_id));
+    if (class_def.class_idx_ == field_id.class_idx_
+        && !field_name.compare(ART_TAINTING_FIELD_NAME)) {
+      cu_->taint_field_idx = i;
+      VLOG(compiler) << "ART_TAINTING - found taint field number (cu_->taint_field_idx): " << cu_->taint_field_idx;
+    }
+  }
+#endif
+
   /* Parse all instructions and put them into containing basic blocks */
   while (code_ptr < code_end) {
     MIR *insn = NewMIR();
@@ -768,6 +790,14 @@ void MIRGraph::InlineMethod(const DexFile::CodeItem* code_item, uint32_t access_
       opcode_count_[static_cast<int>(opcode)]++;
     }
 
+#if ART_TAINTING
+    insn->code_ptr = code_ptr;
+    if (opcode == Instruction::NEW_INSTANCE) {
+      art_taintings_->insert(std::pair<uint32_t, uint32_t>(*code_ptr, 1));
+      VLOG(compiler) << "ART_TAINTING - adding taint for object at address: " << std::hex << code_ptr;
+    }
+#endif
+
     int flags = insn->dalvikInsn.FlagsOf();
     int verify_flags = Instruction::VerifyFlagsOf(insn->dalvikInsn.opcode);
 
diff --git a/compiler/dex/mir_graph.h b/compiler/dex/mir_graph.h
index f038397..f8c727a 100644
--- a/compiler/dex/mir_graph.h
+++ b/compiler/dex/mir_graph.h
@@ -32,6 +32,10 @@
 #include "reg_storage.h"
 #include "utils/arena_bit_vector.h"
 
+#if ART_TAINTING
+#define ART_TAINTING_FIELD_NAME "__taint__"
+#endif
+
 namespace art {
 
 struct CompilationUnit;
@@ -319,6 +323,9 @@ class MIR : public ArenaObject<kArenaAllocMIR> {
     int FlagsOf() const;
   } dalvikInsn;
 
+#if ART_TAINTING
+  const uint16_t* code_ptr;
+#endif
   NarrowDexOffset offset;         // Offset of the instruction in code units.
   uint16_t optimization_flags;
   int16_t m_unit_index;           // From which method was this MIR included
@@ -346,6 +353,9 @@ class MIR : public ArenaObject<kArenaAllocMIR> {
   explicit MIR() : offset(0), optimization_flags(0), m_unit_index(0), bb(NullBasicBlockId),
                  next(nullptr), ssa_rep(nullptr) {
     memset(&meta, 0, sizeof(meta));
+#if ART_TAINTING
+    code_ptr = nullptr;
+#endif
   }
 
   uint32_t GetStartUseIndex() const {
@@ -524,8 +534,13 @@ struct CallInfo {
 };
 
 
+#if ART_TAINTING
+const RegLocation bad_loc = {kLocDalvikFrame, 0, 0, 0, 0, 0, 0, 0, 0, RegStorage(), INVALID_SREG,
+                             INVALID_SREG, 0};
+#else
 const RegLocation bad_loc = {kLocDalvikFrame, 0, 0, 0, 0, 0, 0, 0, 0, RegStorage(), INVALID_SREG,
                              INVALID_SREG};
+#endif
 
 class MIRGraph {
  public:
@@ -561,6 +576,12 @@ class MIRGraph {
     return current_code_item_->insns_;
   }
 
+#if ART_TAINTING
+  std::map<uint32_t, uint32_t>* GetArtTaintings() {
+    return art_taintings_;
+  }
+#endif
+
   /**
    * @brief Used to obtain the raw dex bytecode instruction pointer.
    * @param m_unit_index The method index in MIRGraph (caused by having multiple methods).
@@ -788,8 +809,10 @@ class MIRGraph {
 
   int64_t ConstantValueWide(RegLocation loc) const {
     DCHECK(IsConst(loc));
+#if !ART_TAINTING
     DCHECK(!loc.high_word);  // Do not allow asking for the high partner.
     DCHECK_LT(loc.orig_sreg + 1, GetNumSSARegs());
+#endif
     return (static_cast<int64_t>(constant_values_[loc.orig_sreg + 1]) << 32) |
         Low32Bits(static_cast<int64_t>(constant_values_[loc.orig_sreg]));
   }
@@ -1445,6 +1468,11 @@ class MIRGraph {
 
   static const uint64_t oat_data_flow_attributes_[kMirOpLast];
 
+#if ART_TAINTING
+  std::map<uint32_t, uint32_t>* art_taintings_ = nullptr;
+  friend class Mir2Lir;
+#endif
+
   friend class MirOptimizationTest;
   friend class ClassInitCheckEliminationTest;
   friend class SuspendCheckEliminationTest;
diff --git a/compiler/dex/mir_optimization.cc b/compiler/dex/mir_optimization.cc
index 7679db8..4453fe9 100644
--- a/compiler/dex/mir_optimization.cc
+++ b/compiler/dex/mir_optimization.cc
@@ -270,9 +270,15 @@ size_t MIRGraph::GetNumAvailableVRTemps() {
 }
 
 // FIXME - will probably need to revisit all uses of this, as type not defined.
+#if ART_TAINTING
+static const RegLocation temp_loc = {kLocCompilerTemp,
+                                     0, 1 /*defined*/, 0, 0, 0, 0, 0, 1 /*home*/,
+                                     RegStorage(), INVALID_SREG, INVALID_SREG, 0};
+#else
 static const RegLocation temp_loc = {kLocCompilerTemp,
                                      0, 1 /*defined*/, 0, 0, 0, 0, 0, 1 /*home*/,
                                      RegStorage(), INVALID_SREG, INVALID_SREG};
+#endif
 
 CompilerTemp* MIRGraph::GetNewCompilerTemp(CompilerTempType ct_type, bool wide) {
   // Once the compiler temps have been committed, new ones cannot be requested anymore.
diff --git a/compiler/dex/quick/arm/arm_lir.h b/compiler/dex/quick/arm/arm_lir.h
index 9717459..dcf2611 100644
--- a/compiler/dex/quick/arm/arm_lir.h
+++ b/compiler/dex/quick/arm/arm_lir.h
@@ -302,6 +302,20 @@ constexpr RegStorage rs_dr31(RegStorage::kValid | dr31);
 // RegisterLocation templates return values (r0, r0/r1, s0, or d0).
 // Note: The return locations are shared between quick code and quick helper. This follows quick
 // ABI. Quick helper assembly routine needs to handle the ABI differences.
+#if ART_TAINTING
+const RegLocation arm_loc_c_return
+    {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1,
+     RegStorage(RegStorage::k32BitSolo, r0), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation arm_loc_c_return_wide
+    {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
+     RegStorage(RegStorage::k64BitPair, r0, r1), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation arm_loc_c_return_float
+    {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1,
+     RegStorage(RegStorage::k32BitSolo, r0), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation arm_loc_c_return_double
+    {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
+     RegStorage(RegStorage::k64BitPair, r0, r1), INVALID_SREG, INVALID_SREG, 0};
+#else
 const RegLocation arm_loc_c_return =
     {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1, rs_r0, INVALID_SREG, INVALID_SREG};
 const RegLocation arm_loc_c_return_wide =
@@ -313,6 +327,7 @@ const RegLocation arm_loc_c_return_float = kArm32QuickCodeUseSoftFloat
 const RegLocation arm_loc_c_return_double = kArm32QuickCodeUseSoftFloat
     ? arm_loc_c_return_wide
     : RegLocation({kLocPhysReg, 1, 0, 0, 1, 0, 0, 0, 1, rs_dr0, INVALID_SREG, INVALID_SREG});
+#endif
 
 enum ArmShiftEncodings {
   kArmLsl = 0x0,
diff --git a/compiler/dex/quick/arm64/arm64_lir.h b/compiler/dex/quick/arm64/arm64_lir.h
index 303ea3e..c4aa72b 100644
--- a/compiler/dex/quick/arm64/arm64_lir.h
+++ b/compiler/dex/quick/arm64/arm64_lir.h
@@ -183,6 +183,18 @@ constexpr RegStorage rs_wsp(RegStorage::kValid | rwsp);
 constexpr RegStorage rs_wLR(RegStorage::kValid | rwLR);
 
 // RegisterLocation templates return values (following the hard-float calling convention).
+#if ART_TAINTING
+const RegLocation arm_loc_c_return =
+    {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1, rs_w0, INVALID_SREG, INVALID_SREG, 0};
+const RegLocation arm_loc_c_return_ref =
+    {kLocPhysReg, 0, 0, 0, 0, 0, 1, 0, 1, rs_x0, INVALID_SREG, INVALID_SREG, 0};
+const RegLocation arm_loc_c_return_wide =
+    {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1, rs_x0, INVALID_SREG, INVALID_SREG, 0};
+const RegLocation arm_loc_c_return_float =
+    {kLocPhysReg, 0, 0, 0, 1, 0, 0, 0, 1, rs_f0, INVALID_SREG, INVALID_SREG, 0};
+const RegLocation arm_loc_c_return_double =
+    {kLocPhysReg, 1, 0, 0, 1, 0, 0, 0, 1, rs_d0, INVALID_SREG, INVALID_SREG, 0};
+#else
 const RegLocation a64_loc_c_return =
     {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1, rs_w0, INVALID_SREG, INVALID_SREG};
 const RegLocation a64_loc_c_return_ref =
@@ -193,6 +205,7 @@ const RegLocation a64_loc_c_return_float =
     {kLocPhysReg, 0, 0, 0, 1, 0, 0, 0, 1, rs_f0, INVALID_SREG, INVALID_SREG};
 const RegLocation a64_loc_c_return_double =
     {kLocPhysReg, 1, 0, 0, 1, 0, 0, 0, 1, rs_d0, INVALID_SREG, INVALID_SREG};
+#endif
 
 /**
  * @brief Shift-type to be applied to a register via EncodeShift().
diff --git a/compiler/dex/quick/gen_common.cc b/compiler/dex/quick/gen_common.cc
index 63f83f9..f40300c 100644
--- a/compiler/dex/quick/gen_common.cc
+++ b/compiler/dex/quick/gen_common.cc
@@ -686,9 +686,14 @@ void Mir2Lir::GenSput(MIR* mir, RegLocation rl_src, OpSize size) {
   const MirSFieldLoweringInfo& field_info = mir_graph_->GetSFieldLoweringInfo(mir);
   DCHECK_EQ(SPutMemAccessType(mir->dalvikInsn.opcode), field_info.MemAccessType());
   cu_->compiler_driver->ProcessedStaticField(field_info.FastPut(), field_info.IsReferrersClass());
+#if ART_TAINTING
+  RegStorage r_base;
+#endif
   if (!ForceSlowFieldPath(cu_) && field_info.FastPut()) {
     DCHECK_GE(field_info.FieldOffset().Int32Value(), 0);
+#if !ART_TAINTING
     RegStorage r_base;
+#endif
     if (field_info.IsReferrersClass()) {
       // Fast path, static storage base is this method's class
       r_base = AllocTempRef();
@@ -726,6 +731,53 @@ void Mir2Lir::GenSput(MIR* mir, RegLocation rl_src, OpSize size) {
     if (IsRef(size) && !mir_graph_->IsConstantNullRef(rl_src)) {
       MarkGCCard(mir->optimization_flags, rl_src.reg, r_base);
     }
+
+#if ART_TAINTING && 0
+    std::map<uint16_t, int>::iterator sfields_it = art_taintings_sfields_.find(cu_->class_def_idx);
+    // if (sfields_it != art_taintings_sfields_.end()
+    //     && rl_src.s_reg_low != INVALID_SREG) {
+    //   VLOG(compiler) << "ART_TAINTING: Tainting static field for class (index): " << cu_->class_def_idx;
+    //   StoreRefDisp(r_base, cu_->taint_field_offset, rl_src.reg, kNotVolatile);
+
+    //   // load the new taint value into a register
+    //   RegStorage reg_taint_new_value = AllocTemp();
+    //   LoadConstant(reg_taint_new_value, sfields_it->second);
+
+    //   // load the already stored value into a register
+    //   RegStorage reg_taint_value = AllocTemp();
+    //   LoadBaseDisp(r_base, cu_->taint_field_offset, reg_taint_value, OpSize::kWord, kNotVolatile);
+    //   VLOG(compiler) << "ART_TAINTING: Tainting static field for class (index): " << cu_->class_def_idx;
+
+    //   // logical OR both values
+    //   NewLIR4(kThumb2OrrRRR, reg_taint_new_value.GetReg(), reg_taint_new_value.GetReg(), reg_taint_value.GetReg(), 0);
+
+    //   // store the combined taint value into the object's taint field
+    //   VLOG(compiler) << "ART_TAINTING: Tainting static field for class (index): " << cu_->class_def_idx;
+    //   StoreBaseDisp(r_base, cu_->taint_field_offset, reg_taint_new_value, OpSize::kWord, kNotVolatile);
+    //   VLOG(compiler) << "ART_TAINTING: Tainting static field for class (index): " << cu_->class_def_idx;
+    //   FreeTemp(reg_taint_value);
+    //   FreeTemp(reg_taint_new_value);
+    // }
+    if (sfields_it != art_taintings_sfields_.end() && rl_src.s_reg_low != INVALID_SREG) {
+      // load the new taint value into a register
+      RegStorage reg_taint_new_value = AllocTemp();
+      LoadConstant(reg_taint_new_value, sfields_it->second);
+
+      // load the already stored value into a register
+      RegStorage reg_taint_value = AllocTemp();
+      LoadBaseDisp(r_base, cu_->taint_field_offset, reg_taint_value, OpSize::kWord, kNotVolatile);
+
+      // non-exclusive logical OR both values
+      OpRegRegReg(kOpOr, reg_taint_new_value, reg_taint_new_value, reg_taint_value);
+
+      // store the combined taint value into the object's taint field
+      StoreBaseDisp(r_base, cu_->taint_field_offset, reg_taint_new_value, OpSize::kWord, kNotVolatile);
+      FreeTemp(reg_taint_value);
+      FreeTemp(reg_taint_new_value);
+      VLOG(compiler) << "ART_TAINTING: Tainting static field with offset: " << cu_->taint_field_offset;
+    }
+#endif
+
     FreeTemp(r_base);
   } else {
     FlushAllRegs();  // Everything to home locations
@@ -1003,6 +1055,57 @@ void Mir2Lir::GenIPut(MIR* mir, int opt_flags, OpSize size,
     CallRuntimeHelperImmRegLocationRegLocation(target, field_info.FieldIndex(), rl_obj, rl_src,
                                                true);
   }
+
+#if ART_TAINTING
+  // uint32_t old_field_idx = mir->dalvikInsn.vC;
+  // mir->dalvikInsn.vC = cu_->taint_field_idx;
+  // const MirIFieldLoweringInfo& field_info_taint = mir_graph_->GetIFieldLoweringInfo(mir);
+  // int field_offset_taint = field_info_taint.FieldOffset().Int32Value();
+  // VLOG(compiler) << "ART_TAINTING: Taint field offset (temp.): " << field_offset_taint;
+  // mir->dalvikInsn.vC = old_field_idx;
+
+  // Runtime* runtime = Runtime::Current();
+  // instrumentation::Instrumentation* instrumentation = runtime->GetInstrumentation();
+  // LOG(INFO) << "ART_TAINTING: instrumentation->InterpretOnly(): " << instrumentation->InterpretOnly();
+
+  if (cu_->taint_field_idx >= 0) {
+    MemberOffset field_offset(0u);
+    bool is_volatile;
+    DexCompilationUnit* dex_cu = mir_graph_->GetCurrentDexCompilationUnit();
+    cu_->compiler_driver->ComputeInstanceFieldInfo(cu_->taint_field_idx, dex_cu, true, &field_offset, &is_volatile);
+    cu_->taint_field_offset = field_offset.Int32Value();
+    VLOG(compiler) << "ART_TAINTING: ComputeInstanceFieldInfo: " << cu_->taint_field_offset;
+  }
+
+  if (cu_->taint_field_idx >= 0 &&
+      rl_obj.s_reg_low != INVALID_SREG && rl_obj.taint != 0) {
+    // load the new taint value into a register
+    RegStorage reg_taint_new_value = AllocTemp();
+    LoadConstant(reg_taint_new_value, rl_obj.taint);
+
+    // load the already stored value into a register
+    RegStorage reg_taint_value = AllocTemp();
+    // if (cu_->taint_field_idx == 6409) {
+    //   cu_->taint_field_offset = 8;
+    // }
+    LoadBaseDisp(rl_obj.reg, cu_->taint_field_offset, reg_taint_value, OpSize::kWord, kNotVolatile);
+
+    // non-exclusive logical OR both values
+    OpRegRegReg(kOpOr, reg_taint_new_value, reg_taint_new_value, reg_taint_value);
+
+    // store the combined taint value into the object's taint field
+    if (is_object) {
+      VLOG(compiler) << "ART_TAINTING: Tainting with StoreRefDisp for field with index: " << cu_->taint_field_idx;
+      StoreRefDisp(rl_obj.reg, cu_->taint_field_offset, reg_taint_new_value, kNotVolatile);
+    } else {
+      VLOG(compiler) << "ART_TAINTING: Tainting with StoreBaseDisp for field with index: " << cu_->taint_field_idx;
+      StoreBaseDisp(rl_obj.reg, cu_->taint_field_offset, reg_taint_new_value, OpSize::kWord, kNotVolatile);
+    }
+    FreeTemp(reg_taint_value);
+    FreeTemp(reg_taint_new_value);
+    VLOG(compiler) << "ART_TAINTING: Tainting field with offset: " << cu_->taint_field_offset;
+  }
+#endif
 }
 
 void Mir2Lir::GenArrayObjPut(int opt_flags, RegLocation rl_array, RegLocation rl_index,
diff --git a/compiler/dex/quick/mips/mips_lir.h b/compiler/dex/quick/mips/mips_lir.h
index 078ac0a..58d34cf 100644
--- a/compiler/dex/quick/mips/mips_lir.h
+++ b/compiler/dex/quick/mips/mips_lir.h
@@ -503,6 +503,33 @@ constexpr RegStorage rs_rD30(RegStorage::kValid | rD30);
 constexpr RegStorage rs_rD31(RegStorage::kValid | rD31);
 
 // RegisterLocation templates return values (r_V0, or r_V0/r_V1).
+#if ART_TAINTING
+const RegLocation mips_loc_c_return
+    {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1,
+     RegStorage(RegStorage::k32BitSolo, rV0), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation mips64_loc_c_return_ref
+    {kLocPhysReg, 0, 0, 0, 0, 0, 1, 0, 1,
+     RegStorage(RegStorage::k64BitSolo, rV0d), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation mips_loc_c_return_wide
+    {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
+     RegStorage(RegStorage::k64BitPair, rV0, rV1), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation mips64_loc_c_return_wide
+    {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
+     RegStorage(RegStorage::k64BitSolo, rV0d), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation mips_loc_c_return_float
+    {kLocPhysReg, 0, 0, 0, 1, 0, 0, 0, 1,
+     RegStorage(RegStorage::k32BitSolo, rF0), INVALID_SREG, INVALID_SREG, 0};
+// FIXME: move MIPS to k64Bitsolo for doubles
+const RegLocation mips_loc_c_return_double_fr0
+    {kLocPhysReg, 1, 0, 0, 1, 0, 0, 0, 1,
+     RegStorage(RegStorage::k64BitPair, rF0, rF1), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation mips_loc_c_return_double_fr1
+    {kLocPhysReg, 1, 0, 0, 1, 0, 0, 0, 1,
+     RegStorage(RegStorage::k64BitSolo, rF0), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation mips64_loc_c_return_double
+    {kLocPhysReg, 1, 0, 0, 1, 0, 0, 0, 1,
+     RegStorage(RegStorage::k64BitSolo, rD0), INVALID_SREG, INVALID_SREG, 0};
+#else
 const RegLocation mips_loc_c_return
     {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1,
      RegStorage(RegStorage::k32BitSolo, rV0), INVALID_SREG, INVALID_SREG};
@@ -528,6 +555,7 @@ const RegLocation mips_loc_c_return_double_fr1
 const RegLocation mips64_loc_c_return_double
     {kLocPhysReg, 1, 0, 0, 1, 0, 0, 0, 1,
      RegStorage(RegStorage::k64BitSolo, rD0), INVALID_SREG, INVALID_SREG};
+#endif
 
 enum MipsShiftEncodings {
   kMipsLsl = 0x0,
diff --git a/compiler/dex/quick/mir_to_lir.cc b/compiler/dex/quick/mir_to_lir.cc
index e3e87ec..dc6e0e2 100644
--- a/compiler/dex/quick/mir_to_lir.cc
+++ b/compiler/dex/quick/mir_to_lir.cc
@@ -483,6 +483,14 @@ void Mir2Lir::CompileDalvikInstruction(MIR* mir, BasicBlock* bb, LIR* label_list
   DCHECK(CheckCorePoolSanity()) << PrettyMethod(cu_->method_idx, *cu_->dex_file) << " @ 0x:"
                                 << std::hex << current_dalvik_offset_;
 
+#if ART_TAINTING
+  std::map<uint32_t, uint32_t>* art_taintings = mir_graph_->GetArtTaintings();
+  std::map<uint32_t, uint32_t>::iterator it;
+  CallInfo* call_info = nullptr;
+  int sfields_value = 0;
+  std::map<uint16_t, int>::iterator sfields_it;
+#endif
+
   // Prep Src and Dest locations.
   int next_sreg = 0;
   int next_loc = 0;
@@ -621,6 +629,51 @@ void Mir2Lir::CompileDalvikInstruction(MIR* mir, BasicBlock* bb, LIR* label_list
 
     case Instruction::NEW_INSTANCE:
       GenNewInstance(vB, rl_dest);
+#if ART_TAINTING
+      // VLOG(compiler) << "ART_TAINTING - cu_->class_def_idx: " << cu_->class_def_idx << "\tcu_->method_idx: " << cu_->method_idx;
+      // VLOG(compiler) << "ART_TAINTING - mir->offset: " << mir->offset;
+      if (art_taintings != nullptr && mir->code_ptr != nullptr) {
+        VLOG(compiler) << "ART_TAINTING - mir->code_ptr: " << std::hex << mir->code_ptr;
+        it = art_taintings->find(*mir->code_ptr);
+        if (it == art_taintings->end()) {
+          VLOG(compiler) << "ART_TAINTING - could not find tainting at address: " << std::hex << mir->code_ptr;
+        } else {
+          // taint the virtual dalvik registers
+          rl_result.taint = it->second;
+          rl_dest.taint = it->second;
+          rl_src[0].taint = it->second;
+          rl_src[1].taint = it->second;
+          rl_src[2].taint = it->second;
+
+          // manage the dedicated map for static fields, indexed by class index
+          sfields_value |= it->second;
+          sfields_it = art_taintings_sfields_.find(cu_->class_def_idx);
+          if (sfields_it != art_taintings_sfields_.end()) {
+            sfields_value |= sfields_it->second;
+          }
+          art_taintings_sfields_.insert(std::pair<uint16_t, int>(cu_->class_def_idx, sfields_value));
+
+          if (mir->next != nullptr) {
+            if (mir->next->dalvikInsn.opcode == Instruction::INVOKE_DIRECT) {
+              art_taintings->insert(std::pair<uint32_t, uint32_t>(*mir->next->code_ptr, it->second));
+              VLOG(compiler) << "ART_TAINTING - adding taint for object at address: " << std::hex << mir->next->code_ptr;
+            }
+          }
+
+          // for (int i = 0; i < mir->ssa_rep->num_defs; ++i) {
+          //   VLOG(compiler) << "ART_TAINTING - mir->ssa_rep->defs[" << i << "]: " << mir->ssa_rep->defs[i];
+          // }
+          // for (int i = 0; i < mir->ssa_rep->num_uses; ++i) {
+          //   VLOG(compiler) << "ART_TAINTING - mir->ssa_rep->uses[" << i << "]: " << mir->ssa_rep->uses[i];
+          // }
+          // VLOG(compiler) << "ART_TAINTING - rl_dest.s_reg_low: " << rl_dest.s_reg_low;
+          // VLOG(compiler) << "ART_TAINTING - rl_dest.orig_sreg: " << rl_dest.orig_sreg;
+          // VLOG(compiler) << "ART_TAINTING - rl_dest.location: " << rl_dest.location;
+        }
+      } else {
+        VLOG(compiler) << "ART_TAINTING - mir->code_ptr not set!";
+      }
+#endif
       break;
 
     case Instruction::THROW:
@@ -821,16 +874,28 @@ void Mir2Lir::CompileDalvikInstruction(MIR* mir, BasicBlock* bb, LIR* label_list
     case Instruction::IPUT_WIDE_QUICK:
     case Instruction::IPUT_WIDE:
       GenIPut(mir, opt_flags, rl_src[0].fp ? kDouble : k64, rl_src[0], rl_src[1]);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (IPUT_WIDE): " << rl_src[0].taint;
+      VLOG(compiler) << "ART_TAINTING - rl_src[1].taint (IPUT_WIDE): " << rl_src[1].taint;
+#endif
       break;
 
     case Instruction::IPUT_OBJECT_QUICK:
     case Instruction::IPUT_OBJECT:
       GenIPut(mir, opt_flags, kReference, rl_src[0], rl_src[1]);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (IPUT_OBJECT): " << rl_src[0].taint;
+      VLOG(compiler) << "ART_TAINTING - rl_src[1].taint (IPUT_OBJECT): " << rl_src[1].taint;
+#endif
       break;
 
     case Instruction::IPUT_QUICK:
     case Instruction::IPUT:
       GenIPut(mir, opt_flags, rl_src[0].fp ? kSingle : k32, rl_src[0], rl_src[1]);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (IPUT): " << rl_src[0].taint;
+      VLOG(compiler) << "ART_TAINTING - rl_src[1].taint (IPUT): " << rl_src[1].taint;
+#endif
       break;
 
     case Instruction::IPUT_BYTE_QUICK:
@@ -838,16 +903,28 @@ void Mir2Lir::CompileDalvikInstruction(MIR* mir, BasicBlock* bb, LIR* label_list
     case Instruction::IPUT_BYTE:
     case Instruction::IPUT_BOOLEAN:
       GenIPut(mir, opt_flags, kUnsignedByte, rl_src[0], rl_src[1]);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (IPUT_BOOLEAN): " << rl_src[0].taint;
+      VLOG(compiler) << "ART_TAINTING - rl_src[1].taint (IPUT_BOOLEAN): " << rl_src[1].taint;
+#endif
       break;
 
     case Instruction::IPUT_CHAR_QUICK:
     case Instruction::IPUT_CHAR:
       GenIPut(mir, opt_flags, kUnsignedHalf, rl_src[0], rl_src[1]);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (IPUT_CHAR): " << rl_src[0].taint;
+      VLOG(compiler) << "ART_TAINTING - rl_src[1].taint (IPUT_CHAR): " << rl_src[1].taint;
+#endif
       break;
 
     case Instruction::IPUT_SHORT_QUICK:
     case Instruction::IPUT_SHORT:
       GenIPut(mir, opt_flags, kSignedHalf, rl_src[0], rl_src[1]);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (IPUT_SHORT): " << rl_src[0].taint;
+      VLOG(compiler) << "ART_TAINTING - rl_src[1].taint (IPUT_SHORT): " << rl_src[1].taint;
+#endif
       break;
 
     case Instruction::SGET_OBJECT:
@@ -881,28 +958,46 @@ void Mir2Lir::CompileDalvikInstruction(MIR* mir, BasicBlock* bb, LIR* label_list
 
     case Instruction::SPUT_OBJECT:
       GenSput(mir, rl_src[0], kReference);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (SPUT_OBJECT): " << rl_src[0].taint;
+#endif
       break;
 
     case Instruction::SPUT:
       GenSput(mir, rl_src[0], rl_src[0].fp ? kSingle : k32);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (SPUT): " << rl_src[0].taint;
+#endif
       break;
 
     case Instruction::SPUT_BYTE:
     case Instruction::SPUT_BOOLEAN:
       GenSput(mir, rl_src[0], kUnsignedByte);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (SPUT_BOOLEAN): " << rl_src[0].taint;
+#endif
       break;
 
     case Instruction::SPUT_CHAR:
       GenSput(mir, rl_src[0], kUnsignedHalf);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (SPUT_CHAR): " << rl_src[0].taint;
+#endif
       break;
 
     case Instruction::SPUT_SHORT:
       GenSput(mir, rl_src[0], kSignedHalf);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (SPUT_SHORT): " << rl_src[0].taint;
+#endif
       break;
 
 
     case Instruction::SPUT_WIDE:
       GenSput(mir, rl_src[0], rl_src[0].fp ? kDouble : k64);
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - rl_src[0].taint (SPUT_WIDE): " << rl_src[0].taint;
+#endif
       break;
 
     case Instruction::INVOKE_STATIC_RANGE:
@@ -913,7 +1008,33 @@ void Mir2Lir::CompileDalvikInstruction(MIR* mir, BasicBlock* bb, LIR* label_list
       break;
 
     case Instruction::INVOKE_DIRECT:
+#if ART_TAINTING
+      VLOG(compiler) << "ART_TAINTING - INVOKE_DIRECT address: " << std::hex << mir->code_ptr;
+      call_info = mir_graph_->NewMemCallInfo(bb, mir, kDirect, false);
+      if (art_taintings != nullptr && mir->code_ptr != nullptr) {
+        VLOG(compiler) << "ART_TAINTING - mir->code_ptr: " << std::hex << mir->code_ptr;
+        it = art_taintings->find(*mir->code_ptr);
+        if (it == art_taintings->end()) {
+          VLOG(compiler) << "ART_TAINTING - could not find tainting at address: " << std::hex << mir->code_ptr;
+        } else {
+          call_info->result.taint = it->second;
+          VLOG(compiler) << "ART_TAINTING - &call_info->result.taint: " << std::hex << &call_info->result.taint;
+          for (int i = 0; i < mir->ssa_rep->num_defs; i++) {
+            VLOG(compiler) << "ART_TAINTING - mir->ssa_rep->defs[" << i << "]: " << mir->ssa_rep->defs[i];
+            mir_graph_->reg_location_[mir->ssa_rep->defs[i]].taint = it->second;
+          }
+          for (int i = 0; i < mir->ssa_rep->num_uses; i++) {
+            VLOG(compiler) << "ART_TAINTING - mir->ssa_rep->uses[" << i << "]: " << mir->ssa_rep->uses[i];
+            mir_graph_->reg_location_[mir->ssa_rep->uses[i]].taint = it->second;
+          }
+        }
+      } else {
+        VLOG(compiler) << "ART_TAINTING - mir->code_ptr not set!";
+      }
+      GenInvoke(call_info);
+#else
       GenInvoke(mir_graph_->NewMemCallInfo(bb, mir, kDirect, false));
+#endif
       break;
     case Instruction::INVOKE_DIRECT_RANGE:
       GenInvoke(mir_graph_->NewMemCallInfo(bb, mir, kDirect, true));
diff --git a/compiler/dex/quick/mir_to_lir.h b/compiler/dex/quick/mir_to_lir.h
index d54616f..6a468ed 100644
--- a/compiler/dex/quick/mir_to_lir.h
+++ b/compiler/dex/quick/mir_to_lir.h
@@ -1805,6 +1805,10 @@ class Mir2Lir {
     MIR* current_mir_;
     size_t estimated_native_code_size_;     // Just an estimate; used to reserve code_buffer_ size.
     std::unique_ptr<RegisterPool> reg_pool_;
+
+#if ART_TAINTING
+    std::map<uint16_t, int> art_taintings_sfields_;
+#endif
     /*
      * Sanity checking for the register temp tracking.  The same ssa
      * name should never be associated with one temp register per
diff --git a/compiler/dex/quick/x86/int_x86.cc b/compiler/dex/quick/x86/int_x86.cc
index 9bbb5f8..091555d 100755
--- a/compiler/dex/quick/x86/int_x86.cc
+++ b/compiler/dex/quick/x86/int_x86.cc
@@ -698,8 +698,13 @@ RegLocation X86Mir2Lir::GenDivRemLit(RegLocation rl_dest, RegLocation rl_src,
     LockTemp(rs_r2);
 
     // Assume that the result will be in EDX for divide, and EAX for remainder.
+#if ART_TAINTING
+    rl_result = {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1, is_div ? rs_r2 : rs_r0,
+                 INVALID_SREG, INVALID_SREG, 0};
+#else
     rl_result = {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1, is_div ? rs_r2 : rs_r0,
                  INVALID_SREG, INVALID_SREG};
+#endif
 
     // We need the value at least twice.  Load into a temp.
     rl_src = LoadValue(rl_src, kCoreReg);
@@ -823,7 +828,11 @@ RegLocation X86Mir2Lir::GenDivRem(RegLocation rl_dest, RegLocation rl_src1,
   done->target = NewLIR0(kPseudoTargetLabel);
 
   // Result is in EAX for div and EDX for rem.
+#if ART_TAINTING
+  RegLocation rl_result = {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1, rs_r0, INVALID_SREG, INVALID_SREG, 0};
+#else
   RegLocation rl_result = {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1, rs_r0, INVALID_SREG, INVALID_SREG};
+#endif
   if (!is_div) {
     rl_result.reg.SetReg(r2);
   }
@@ -1784,8 +1793,13 @@ bool X86Mir2Lir::GenMulLongConst(RegLocation rl_dest, RegLocation rl_src1, int64
     NewLIR2(kX86Add32RR, rs_r2.GetReg(), rs_r1.GetReg());
 
     // Result is EDX:EAX
+#if ART_TAINTING
+    RegLocation rl_result = {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
+                             RegStorage::MakeRegPair(rs_r0, rs_r2), INVALID_SREG, INVALID_SREG, 0};
+#else
     RegLocation rl_result = {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
                              RegStorage::MakeRegPair(rs_r0, rs_r2), INVALID_SREG, INVALID_SREG};
+#endif
     StoreValueWide(rl_dest, rl_result);
     return true;
   }
@@ -1923,8 +1937,13 @@ void X86Mir2Lir::GenMulLong(Instruction::Code, RegLocation rl_dest, RegLocation
   NewLIR2(kX86Add32RR, rs_r2.GetReg(), rs_r1.GetReg());
 
   // Result is EDX:EAX
+#if ART_TAINTING
+  RegLocation rl_result = {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
+                           RegStorage::MakeRegPair(rs_r0, rs_r2), INVALID_SREG, INVALID_SREG, 0};
+#else
   RegLocation rl_result = {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
                            RegStorage::MakeRegPair(rs_r0, rs_r2), INVALID_SREG, INVALID_SREG};
+#endif
   StoreValueWide(rl_dest, rl_result);
 }
 
@@ -2194,8 +2213,13 @@ void X86Mir2Lir::GenDivRemLongLit(RegLocation rl_dest, RegLocation rl_src,
     Clobber(rs_r2q);
     LockTemp(rs_r2q);
 
+#if ART_TAINTING
+    RegLocation rl_result = {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
+                             is_div ? rs_r2q : rs_r0q, INVALID_SREG, INVALID_SREG, 0};
+#else
     RegLocation rl_result = {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
                              is_div ? rs_r2q : rs_r0q, INVALID_SREG, INVALID_SREG};
+#endif
 
     // Use H.S.Warren's Hacker's Delight Chapter 10 and
     // T,Grablund, P.L.Montogomery's Division by invariant integers using multiplication.
@@ -2363,7 +2387,11 @@ void X86Mir2Lir::GenDivRemLong(Instruction::Code, RegLocation rl_dest, RegLocati
   done->target = NewLIR0(kPseudoTargetLabel);
 
   // Result is in RAX for div and RDX for rem.
+#if ART_TAINTING
+  RegLocation rl_result = {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1, rs_r0q, INVALID_SREG, INVALID_SREG, 0};
+#else
   RegLocation rl_result = {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1, rs_r0q, INVALID_SREG, INVALID_SREG};
+#endif
   if (!is_div) {
     rl_result.reg.SetReg(r2q);
   }
diff --git a/compiler/dex/quick/x86/x86_lir.h b/compiler/dex/quick/x86/x86_lir.h
index 57db015..504aa5b 100644
--- a/compiler/dex/quick/x86/x86_lir.h
+++ b/compiler/dex/quick/x86/x86_lir.h
@@ -321,6 +321,29 @@ constexpr RegStorage rs_rX86_RET0 = rs_rAX;
 constexpr RegStorage rs_rX86_RET1 = rs_rDX;
 
 // RegisterLocation templates return values (r_V0, or r_V0/r_V1).
+#if ART_TAINTING
+const RegLocation x86_loc_c_return
+    {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1,
+     RegStorage(RegStorage::k32BitSolo, rAX), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation x86_loc_c_return_wide
+    {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
+     RegStorage(RegStorage::k64BitPair, rAX, rDX), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation x86_loc_c_return_ref
+    {kLocPhysReg, 0, 0, 0, 0, 0, 1, 0, 1,
+     RegStorage(RegStorage::k32BitSolo, rAX), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation x86_64_loc_c_return_ref
+    {kLocPhysReg, 0, 0, 0, 0, 0, 1, 0, 1,
+     RegStorage(RegStorage::k64BitSolo, rAX), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation x86_64_loc_c_return_wide
+    {kLocPhysReg, 1, 0, 0, 0, 0, 0, 0, 1,
+     RegStorage(RegStorage::k64BitSolo, rAX), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation x86_loc_c_return_float
+    {kLocPhysReg, 0, 0, 0, 1, 0, 0, 0, 1,
+     RegStorage(RegStorage::k32BitSolo, fr0), INVALID_SREG, INVALID_SREG, 0};
+const RegLocation x86_loc_c_return_double
+    {kLocPhysReg, 1, 0, 0, 1, 0, 0, 0, 1,
+     RegStorage(RegStorage::k64BitSolo, dr0), INVALID_SREG, INVALID_SREG, 0};
+#else
 const RegLocation x86_loc_c_return
     {kLocPhysReg, 0, 0, 0, 0, 0, 0, 0, 1,
      RegStorage(RegStorage::k32BitSolo, rAX), INVALID_SREG, INVALID_SREG};
@@ -342,6 +365,7 @@ const RegLocation x86_loc_c_return_float
 const RegLocation x86_loc_c_return_double
     {kLocPhysReg, 1, 0, 0, 1, 0, 0, 0, 1,
      RegStorage(RegStorage::k64BitSolo, dr0), INVALID_SREG, INVALID_SREG};
+#endif
 
 /*
  * The following enum defines the list of supported X86 instructions by the
diff --git a/compiler/dex/reg_location.h b/compiler/dex/reg_location.h
index aa8ed46..53a9d12 100644
--- a/compiler/dex/reg_location.h
+++ b/compiler/dex/reg_location.h
@@ -54,6 +54,10 @@ struct RegLocation {
   int16_t s_reg_low;    // SSA name for low Dalvik word.
   int16_t orig_sreg;    // TODO: remove after Bitcode gen complete
                         // and consolidate usage w/ s_reg_low.
+
+#if ART_TAINTING
+  uint32_t taint;
+#endif
 };
 
 }  // namespace art
diff --git a/compiler/dex/vreg_analysis.cc b/compiler/dex/vreg_analysis.cc
index 948ba7b..24f0034 100644
--- a/compiler/dex/vreg_analysis.cc
+++ b/compiler/dex/vreg_analysis.cc
@@ -39,8 +39,13 @@ void MIRGraph::DumpRegLocTable(RegLocation* table, int count) {
 }
 
 // FIXME - will likely need to revisit all uses of this.
+#if ART_TAINTING
+static const RegLocation fresh_loc = {kLocDalvikFrame, 0, 0, 0, 0, 0, 0, 0, 0,
+                                      RegStorage(), INVALID_SREG, INVALID_SREG, 0};
+#else
 static const RegLocation fresh_loc = {kLocDalvikFrame, 0, 0, 0, 0, 0, 0, 0, 0,
                                       RegStorage(), INVALID_SREG, INVALID_SREG};
+#endif
 
 void MIRGraph::InitRegLocations() {
   // Allocate the location map. We also include the maximum possible temps because
